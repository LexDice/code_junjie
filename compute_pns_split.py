from shanapy.models.stats.principal_nested_spheres import PNS
from sklearn.decomposition import PCA
import matplotlib.pyplot as plt
import numpy as np
import scipy
from classification import Classification
from dwd.socp_dwd import DWD
from sklearn import metrics
import os


def get_header_info(file_path):
    '''
    Read the header information in the momentum file
    :param file_path: path to the momentum file generated by deformetrica
    :return:
        -num_sbjs: number of subjects
        -num_ctrl_pts: number of control points
    '''
    with open(file_path) as f:
        line = f.readline()
        hdr_info = line.strip().split(' ')

    num_sbjs = int(hdr_info[0])
    num_ctrl_pts = int(hdr_info[1])
    return num_sbjs, num_ctrl_pts


def get_momenta(file_path, num_ctrl_pts, num_sbjs):
    '''
    Read the momenta file generated from deformetrica
    :param file_path: path to the momentum file generated by deformetrica
    :param num_ctrl_pts: number of control points
    :param num_sbjs: number of subjects
    :return:
    '''
    with open(file_path) as f:
        lines = f.readlines()[1:]

    all_cases = np.zeros((num_sbjs, num_ctrl_pts, 3), dtype=float)
    for i in range(num_sbjs):
        one_case = lines[(i*num_ctrl_pts+i+1):((i+1)*num_ctrl_pts+i+1)]
        for idx, s in enumerate(one_case):
            # strip the newline character EOL
            s = s.strip().split(' ')
            # convert to numbers
            s = [float(str_s) for str_s in s]
            one_case[idx] = s

        all_cases[i, :, :] = one_case
        # all_cases[i] = one_case

    return all_cases


def read_momenta(momenta_file_path):
    '''
    Return the read momenta
    :param momenta_file_path: path to the momentum file
    :return: 3d numpy array, shape: [num_sbjs, num_ctrl_pts, 3]
    '''
    num_sbjs, num_ctrl_pts = get_header_info(momenta_file_path)

    # read momenta file
    _momenta = get_momenta(momenta_file_path, num_ctrl_pts, num_sbjs)
    return _momenta


def get_euclid_features(momenta):
    '''
    Euclideanize features obtained from momenta
    :param momenta: momenta array
    :return: euclideanized features
    '''
    num_sbjs = momenta.shape[0]
    num_ctrl_pts = momenta.shape[1]

    # vector norm
    momenta_lens = np.sqrt(np.sum(np.square(momenta), axis=2))

    # compute the geo mean
    log_lens = np.log(momenta_lens)
    log_lens_mean = np.average(log_lens, axis=0)

    # First feature
    f_1 = log_lens - log_lens_mean[np.newaxis, :]

    # normalize to unit vectors
    normalized_momenta = np.divide(momenta, momenta_lens[:, :, np.newaxis])

    # apply PNS
    f_2 = np.zeros((num_sbjs, num_ctrl_pts), dtype=float)
    f_3 = np.zeros((num_sbjs, num_ctrl_pts), dtype=float)
    for i in range(num_ctrl_pts):
        data = np.transpose(normalized_momenta[:, i, :])
        pns_model = PNS(data, itype=9)
        pns_model.fit()
        resmat, PNS_coords = pns_model.output
        f_2[:, i] = resmat[0]
        f_3[:, i] = resmat[1]

    f_combined = np.concatenate((f_1, f_2, f_3), axis=1)

    return f_combined


if __name__ == '__main__':
    neg_file_path = '/Users/junjiezhao/unc/Classes/COMP790/code/new_code/output_neg_set/DeterministicAtlas__EstimatedParameters__Momenta.txt'
    pos_file_path = '/Users/junjiezhao/unc/Classes/COMP790/code/new_code/output_pos_set/DeterministicAtlas__EstimatedParameters__Momenta.txt'
    train_momenta_folder = '/Users/junjiezhao/unc/Classes/COMP790/code/new_code/training_folds_split'

    num_splits = 8
    N_POS_SAMPLES = 34
    N_NEG_SAMPLES = 143

    # read momenta
    pos_momenta = read_momenta(pos_file_path)
    neg_momenta = read_momenta(neg_file_path)
    momenta = np.concatenate((pos_momenta, neg_momenta), axis=0)
    labels = np.array([1] * pos_momenta.shape[0] + [0] * neg_momenta.shape[0])

    # Euclideanize momenta features
    euclid_momenta = get_euclid_features(momenta)

    # perform PCA
    pca_comps = euclid_momenta.shape[0] - 1
    pca_model = PCA(n_components=pca_comps)
    derived_features = pca_model.fit_transform(euclid_momenta)

    # # read momenta of global mean -> training fold mean
    # train_fold_momenta = np.empty((0, pos_momenta.shape[1], pos_momenta.shape[2]))
    # for i in range(num_splits):
    #     momenta_filepath = os.path.join(train_momenta_folder, f"split{i}", 'DeterministicAtlas__EstimatedParameters__Momenta.txt')
    #     split_momenta = read_momenta(momenta_filepath)
    #     train_fold_momenta = np.concatenate((train_fold_momenta, split_momenta), axis=0)
    #
    # # euclideanized momenta from global mean to training fold:i mean
    # euclid_train_features = get_euclid_features(train_fold_momenta)
    # # project to PCA components
    # derived_train_features = pca_model.transform(euclid_train_features)

    aucs = []
    for i in range(1000):
        # composite global momentum and training set momentum
        # composite_features = derived_features - derived_train_features[i]

        X_train, X_test, y_train, y_test = Classification.partition(derived_features, labels, 0.2, i)

        dwd = DWD().fit(X_train, y_train)
        # euclid_X_test_trans = pca_model.transform(euclid_X_test)
        y_pred = dwd.decision_function(X_test)
        fpr, tpr, thresholds = metrics.roc_curve(y_test, y_pred, pos_label=1)

        roc_auc = metrics.auc(fpr, tpr)
        aucs.append(roc_auc)

    print(np.mean(aucs))